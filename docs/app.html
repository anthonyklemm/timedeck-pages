<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TapeDeck Time Machine</title>

  <!-- MusicKit JS -->
  <script src="https://js-cdn.music.apple.com/musickit/v3/musickit.js"></script>

  <!-- Meta / Social -->
  <meta name="description" content="Rewind the radio you grew up with. Generate playlists from any date and genre, powered by Billboard chart data.">
  <link rel="icon" href="/logo.svg" type="image/svg+xml"><!-- no favicon.ico until you add one -->
  <link rel="apple-touch-icon" href="/logo.svg">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tapedecktimemachine.com/">
  <meta property="og:title" content="TapeDeck Time Machine - Historical Music Playlist Generator">
  <meta property="og:description" content="Rewind the radio you grew up with. Generate playlists from any date and genre.">
  <meta property="og:image" content="https://tapedecktimemachine.com/tapedeck-preview.png">
  <meta property="og:image:width" content="1200"><meta property="og:image:height" content="630">
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://tapedecktimemachine.com/">
  <meta property="twitter:title" content="TapeDeck Time Machine - Historical Music Playlist Generator">
  <meta property="twitter:description" content="Rewind the radio you grew up with. Generate playlists from any date and genre.">
  <meta property="twitter:image" content="https://tapedecktimemachine.com/tapedeck-preview.png">

  <!-- GA -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HPZT6BMJVD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-HPZT6BMJVD');
  </script>

  <style>
    :root{
      --bg:#0a0f17;--panel:#111827;--muted:#94a3b8;--text:#e5e7eb;
      --accent:#8b5cf6;--accent2:#22d3ee;--shadow:0 12px 48px rgba(2,10,20,.45)
    }
    *{box-sizing:border-box}
    body{margin:0;background:
      radial-gradient(1200px 600px at 10% -10%, #0e1630 0%, transparent 60%),
      radial-gradient(700px 400px at 120% 10%, #06101f 0%, transparent 60%), #0a0f17;
      color:var(--text); font:16px/1.5 -apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;}
    .wrap{max-width:1100px;margin:40px auto;padding:0 18px}
    .bar{display:flex;align-items:center;gap:14px}
    .bar a { color: inherit; text-decoration: none; display: flex; align-items: center; gap: 14px; }
    .logo{width:36px;height:36px;border-radius:12px;background:
      linear-gradient(135deg,#8b5cf6 0%,#22d3ee 55%,#16a34a 120%);
      display:grid;place-items:center;color:#fff;font-weight:800;box-shadow:var(--shadow);text-decoration:none; flex-shrink: 0;}
    h1{font-size:22px;margin:0}
    .panel{background:rgba(17,24,39,.75);border:1px solid rgba(148,163,184,.12);
      border-radius:18px;padding:16px;box-shadow:var(--shadow)}
    .grid{display:grid;grid-template-columns:1.2fr 1fr 1fr 1fr 1fr auto; gap:12px; align-items:end}
    label{font-size:12px;color:var(--muted);display:block;margin:0 0 6px 2px}
    input,select,button{width:100%;padding:12px;border-radius:12px;border:1px solid rgba(148,163,184,.18);
      background:#0c1422;color:var(--text);outline:none;font-size:1rem}
    button.primary{background:linear-gradient(135deg,var(--accent),var(--accent2));border:0;font-weight:700;cursor:pointer}
    button:disabled{background:#475569;color:#cbd5e1;cursor:not-allowed}
    .tabs{display:flex;gap:10px;margin:14px 0 8px}
    .tab{padding:9px 14px;border-radius:999px;border:1px solid rgba(148,163,184,.2);
      background:#0c1422;color:var(--text);cursor:pointer}
    .tab.active{background:linear-gradient(135deg,rgba(139,92,246,.25),rgba(34,211,238,.18));border-color:transparent}
    .cols{display:grid;grid-template-columns:1.05fr .95fr; gap:16px}
    .box{min-height:380px}
    iframe{width:100%;height:360px;border:0;border-radius:12px;box-shadow:var(--shadow)}
    .btn{display:inline-block;margin-top:8px;padding:10px 14px;border-radius:12px;border:1px solid rgba(148,163,184,.2);
      background:#0c1422;color:#e5e7eb;text-decoration:none;font-weight:700;cursor:pointer}
    .btn.inline{padding:8px 10px}
    .btn.ghost{background:transparent}
    .muted{color:var(--muted)}
    .list{padding:12px 8px;max-height:420px;overflow:auto}
    .row{display:grid;grid-template-columns:110px 1fr;gap:14px; padding:10px 6px;border-bottom:1px dashed rgba(148,163,184,.12)}
    .ts{font:12px/1.3 ui-monospace,SFMono-Regular,Menlo,monospace;color:var(--muted)}
    .err{color:#fda4af;margin-top:6px; white-space: pre-wrap; word-break: break-all;}
    .ok{color:#86efac;margin-top:6px}

    /* Embed styles (REMOVED) */
    .linkRow{display:flex; gap:10px; flex-wrap:wrap}

    /* Simple Player styles (RESTORED) */
    .simplePlayer { display: none; margin-top: 12px; background: rgba(12,20,34,.8); border:1px solid rgba(148,163,184,.12); border-radius:14px; padding:10px; }
    .simplePlayer .spRow1 { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
    .simplePlayer .spMeta { min-width: 0; }
    .simplePlayer .spTitle { font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .simplePlayer .spControls { display: flex; gap: 6px; align-items: center; }
    .simplePlayer .spControls .btn { padding: 6px 10px; margin-top: 0; } /* Removed margin-top */
    .simplePlayer .spMsg { font-size: 11px; margin-top: 4px; color: var(--muted); }

    @media (max-width:800px){.grid{grid-template-columns:1fr 1fr}.grid>div:last-child{grid-column:1/-1}}
    @media (max-width:700px){.wrap{margin:20px auto}.cols{grid-template-columns:1fr}h1{font-size:18px}}
    @media (max-width:500px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>

<div class="wrap">
  <!-- Link added to logo/title -->
  <div class="bar" style="margin-bottom:14px">
    <a href="/">
      <div class="logo">TD</div>
      <h1>TapeDeck Time Machine</h1>
    </a>
  </div>

  <!-- Controls -->
  <div class="panel">
    <!-- ... (Grid remains the same) ... -->
    <div class="grid">
      <div><label>Date</label><input id="date" placeholder="mm/dd/yyyy" value="07/01/2002"></div>
      <div><label>Genre</label>
        <select id="genre"> <option>Alternative</option><option>Hot-100</option><option>Pop</option><option>Rock</option><option>Country</option><option>R&B/Hip-Hop</option><option>Dance/Electronic</option> </select>
      </div>
      <div><label>Hours</label><select id="hours"><option>0.5</option><option selected>1</option><option>2</option><option>3</option></select></div>
      <div><label>Repeat gap (min)</label><input id="gap" type="number" value="90"></div>
      <div><label>Seed (opt)</label><input id="seed" placeholder="e.g. 20020701"></div>
      <div><label>&nbsp;</label><button id="go" class="primary">Generate</button></div>
    </div>

    <!-- ... (Tabs remain the same) ... -->
    <div class="tabs"> <button class="tab active" data-tab="yt">YouTube</button> <button class="tab" data-tab="am">Apple Music</button> <button class="tab" data-tab="sp" disabled title="Coming soon">Spotify</button> </div>
    <div class="muted" style="margin:-6px 0 8px 2px">Spotify sign-in is under construction. Coming soon!</div>

    <div class="cols">
      <!-- YouTube -->
      <div class="panel box" id="pane-yt">
        <div id="ytWrap">
          <div class="muted" id="ytStatus">Waiting for a simulation…</div>
          <div id="ytp"></div>
          <a class="btn" id="ytOpen" href="#" target="_blank" rel="noopener" style="display:none">Open in YouTube</a>
          <div id="ytErr" class="err"></div>
        </div>
      </div>

      <!-- Apple Music Pane -->
      <div class="panel box" id="pane-am" style="display:none">
        <div id="amWrap">
          <p class="muted" style="margin-bottom:8px">Generate a list, sign in, then create or play the playlist.</p>
          <div class="linkRow">
            <button class="btn" id="amSign">Sign in to Apple Music</button>
            <button class="btn" id="amCreate" style="display:none">Create Playlist</button>
            <button class="btn" id="amPlay" style="display:none">Play Playlist</button>
          </div>
          <div id="amMsg" class="muted" style="margin-top:8px"></div>

          <!-- Simple Player (RESTORED) -->
          <div id="simplePlayer" class="simplePlayer">
            <div class="spRow1">
              <div class="spMeta">
                <div id="spTitle" class="spTitle">—</div>
              </div>
              <div class="spControls">
                <button id="spBtnPrev" class="btn inline ghost" title="Previous">⟨⟨</button>
                <button id="spBtnPlayPause" class="btn inline" title="Play/Pause">▶</button>
                <button id="spBtnNext" class="btn inline ghost" title="Next">⟩⟩</button>
              </div>
            </div>
             <div id="spMsg" class="spMsg"></div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- Tracklist -->
  <div class="panel" style="margin-top:16px">
     <h2>Your Music Time Machine Playlist</h2>
     <p class="muted" style="margin-bottom:6px">
       Ever wonder <strong>what songs were popular on your birthday?</strong>
       Just pick a date and genre, and we'll <strong>generate a music playlist</strong>
       of the top songs from that week, based on <strong>historical Billboard charts</strong>.
       The tracklist will appear below.
     </p>
     <div id="list" class="list"></div>
  </div>
</div>

<script>
  // ---------- config & helpers ----------
  const qs = s => document.querySelector(s);
  const API = new URLSearchParams(location.search).get('api') || 'https://timedeck-api.onrender.com';
  const NET_TIMEOUT_MS = 180000;
  const NATIVE_HOST = 'https://tapedecktimemachine.com';
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function toISO(mmddyyyy){
    try {
      const parts = mmddyyyy.split('/');
      if (parts.length !== 3) throw new Error('Invalid date format');
      const [mm,dd,yyyy] = parts.map(p => p.trim());
      if (yyyy.length !== 4 || isNaN(parseInt(yyyy))) throw new Error('Invalid year format');
      return `${yyyy}-${mm.padStart(2,'0')}-${dd.padStart(2,'0')}`;
    } catch (e) {
      console.error("Date parsing error:", e);
      qs('#ytErr').textContent = `Invalid date format. Please use MM/DD/YYYY.`;
      throw e;
    }
  }
  function setTab(id){
    document.querySelectorAll('.tab').forEach(b=>b.classList.toggle('active', b.dataset.tab===id));
    qs('#pane-yt').style.display = id==='yt' ? '' : 'none';
    qs('#pane-am').style.display = id==='am' ? '' : 'none';
  }
  document.querySelectorAll('.tab').forEach(b=>b.onclick=()=>setTab(b.dataset.tab));
  function withTimeout(promise, ms = NET_TIMEOUT_MS) {
    let t; const timer = new Promise((_, rej)=>{ t=setTimeout(()=>rej(new Error(`Network timeout after ${Math.round(ms/1000)}s`)), ms); });
    return Promise.race([promise.finally(()=>clearTimeout(t)), timer]);
  }

  // ---------- state ----------
  let lastTracks = [];
  let DEV_TOKEN = null;
  let currentPlaylistInfo = { id: null, url: null, storefront: 'us' };

  // ---------- YouTube ----------
  let player = null, YTapiReady = false;
  (function(){ const tag=document.createElement('script'); tag.src="https://www.youtube.com/iframe_api"; document.head.appendChild(tag); })();
  window.onYouTubeIframeAPIReady = () => { YTapiReady = true; console.log("YT API Ready"); };

  async function simulate(){
    qs('#go').disabled = true;
    qs('#ytStatus').textContent = 'Building…';
    qs('#ytErr').textContent = '';
    qs('#list').innerHTML = '';
    lastTracks = [];
    showSimplePlayer(false); // Hide simple player
    if (player) { try{ player.destroy(); }catch{} player = null; }
    qs('#ytp').innerHTML = '';
    qs('#ytp').style.display = 'none';
    qs('#ytOpen').style.display = 'none';
    qs('#amMsg').textContent = ''; // Clear AM message

    try{
      const body = {
        date: toISO(qs('#date').value.trim()),
        genre: qs('#genre').value,
        hours: Number(qs('#hours').value || 3),
        repeat_gap_min: Number(qs('#gap').value || 90),
        seed: (qs('#seed').value.trim() || undefined) ? String(qs('#seed').value.trim()) : undefined,
        limit: 500
      };
      const r = await withTimeout(fetch(`${API}/v1/simulate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(body) }));
      if(!r.ok){ const txt = await r.text().catch(()=> ''); throw new Error(`simulate ${r.status}: ${txt}`); }
      const data = await r.json();
      lastTracks = data.tracks || [];
      if(!lastTracks.length){ qs('#ytStatus').textContent=''; qs('#ytErr').textContent='No tracks returned. Try a different date/genre.'; return; }
      renderList(lastTracks);
      // Only build YouTube if the tab is active
      if (qs('.tab[data-tab="yt"]').classList.contains('active')) {
          buildYouTube(lastTracks);
      } else {
          qs('#ytStatus').textContent = 'Playlist generated. Switch to YouTube tab to play.';
      }
    }catch(err){
      console.error('[simulate] failed:', err);
      if (!qs('#ytErr').textContent) { qs('#ytErr').textContent = err.message || String(err); }
      qs('#ytStatus').textContent = '';
    } finally {
      qs('#go').disabled = false;
    }
  }

  function renderList(rows){
    if(!rows?.length){ qs('#list').innerHTML = '<div class="muted">No tracks.</div>'; return; }
    const frag = document.createDocumentFragment();
    rows.slice(0,500).forEach(t=>{
      const d = document.createElement('div'); d.className='row';
      d.innerHTML = `<div class="ts">${t.timestamp.replace('T',' ')}</div>
                     <div><strong>${t.artist}</strong> — <em>${t.title}</em>
                     <span class="muted">• ${t.source_rank ?? ''}</span></div>`;
      frag.appendChild(d);
    });
    qs('#list').replaceChildren(frag);
  }

  async function buildYouTube(tracks){
    qs('#ytStatus').textContent = 'Resolving YouTube IDs…';
    qs('#ytErr').textContent = '';
    try{
      const r = await withTimeout(fetch(`${API}/v1/yt/resolve`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ tracks: tracks.map(t=>({artist:t.artist,title:t.title})), limit:50 }) }));
      if(!r.ok){ throw new Error(`yt/resolve ${r.status}: ${await r.text()}`); }
      const data = await r.json();
      const ids = (data.ids || []).filter(Boolean);
      if(!ids.length){ qs('#ytStatus').textContent = 'No playable videos found (try another date/genre).'; return; }
      const openUrl = `https://www.youtube.com/watch_videos?video_ids=${ids.join(',')}`;
      qs('#ytOpen').href = openUrl;
      qs('#ytOpen').style.display = 'inline-block';
      qs('#ytStatus').textContent = `${ids.length} videos found. Loading player...`;
      if (player) {
        try{ player.cuePlaylist(ids, 0, 0); qs('#ytStatus').textContent = `${ids.length} videos queued.`; }
        catch(e) { console.error("YT cuePlaylist failed:", e); player = null; }
      }
      if (!player) {
        if (YTapiReady && qs('.tab[data-tab="yt"]').classList.contains('active')) {
          console.log("YT: Creating new player instance...");
          qs('#ytp').style.display = 'block';
          player = new YT.Player('ytp', {
            height: '360', width: '100%', playerVars: { playsinline: 1, rel: 0, modestbranding: 1, origin: location.origin },
            events: {
              onReady: (e) => {
                console.log("YT Player Ready, cueing playlist...");
                try { e.target.cuePlaylist(ids, 0, 0); qs('#ytStatus').textContent = `${ids.length} videos queued.`; }
                catch (cueError) { console.error("YT cuePlaylist in onReady failed:", cueError); qs('#ytStatus').textContent = 'Error loading videos into player.'; qs('#ytErr').textContent = cueError.message || String(cueError); }
              },
              onError: (e) => { console.error("YT Player Error:", e.data); qs('#ytErr').textContent = `Youtubeer Error: ${e.data}`; }
            }
          });
        } else if (!YTapiReady) { qs('#ytStatus').textContent = 'YouTube API is still loading. Use "Open in YouTube".'; }
        else { qs('#ytStatus').textContent = `${ids.length} videos ready. Switch to YouTube tab to play.`; }
      }
    }catch(err){ console.error("[buildYouTube] failed:", err); qs('#ytErr').textContent = err.message || String(err); qs('#ytStatus').textContent = ''; }
  }


  // ---------- Universal Link / custom-scheme listener (native) ----------
  (function(){
    const Cap = window.Capacitor || {}; const App = Cap.Plugins && Cap.Plugins.App;
    function parseQuery(u){ const i = u.indexOf('?'); if (i < 0) return {}; const q = u.slice(i+1).split('&'); const out = {}; for (const p of q) { const [k,v] = p.split('='); out[decodeURIComponent(k)] = decodeURIComponent(v||''); } return out; }
    if (App && App.addListener) {
      App.addListener('appUrlOpen', ({ url }) => {
        console.log('[appUrlOpen]', url); if (!url || !url.startsWith('com.tapedecktimemachine.app://auth/callback')) return;
        const q = parseQuery(url); if (q.token) { localStorage.setItem('appleMusicUserToken', q.token); updateAmUIState(); getMusicInstance().catch(e => console.warn("[AM Init BG after native auth]", e)); }
        else { console.warn('[appUrlOpen] Received callback without token:', url); qs('#amMsg').textContent = 'Sign-in callback received, but no token found.'; }
      }); console.log('[AM] appUrlOpen listener attached');
    } else { console.warn('[AM] Capacitor App plugin not available for appUrlOpen listener.'); }
  })();


  // ---------- MusicKit Initialization (V13 - const/let fix applied) ----------
  let musicInstance = null;
  let musicInstancePromise = null;

  function waitForMusicKitLoaded(timeoutMs = 15000) {
    if (window.MusicKit && typeof window.MusicKit.configure === 'function') return Promise.resolve();
    return new Promise((resolve, reject) => {
      console.log('[AM Wait] Waiting for MusicKit script load...');
      const t = setTimeout(() => { console.error('[AM Wait] MusicKit load timed out.'); reject(new Error('MusicKit load timed out')); }, timeoutMs);
      window.addEventListener('musickitloaded', () => { console.log('[AM Wait] MusicKit script loaded.'); clearTimeout(t); resolve(); }, { once: true });
    });
  }

  async function fetchDeveloperToken() {
    if (DEV_TOKEN) return DEV_TOKEN;
    console.log('[AM Fetch Token] Fetching dev token...');
    const r = await withTimeout(fetch(`${API}/v1/apple/dev-token`, { headers: { 'accept':'application/json' } }));
    if (!r.ok) throw new Error(`dev-token ${r.status}`);
    const { token, storefront } = await r.json();
    if (!token || typeof token !== 'string' || token.trim().length < 20) throw new Error('Invalid developer token');
    DEV_TOKEN = token.trim();
    window.mkDefaultStorefront = storefront || 'us';
    console.log('[AM Fetch Token] Token fetched and cached.');
    return DEV_TOKEN;
  }

  // Configure MusicKit - Returns the INSTANCE
  async function configureMusicKit() {
    await waitForMusicKitLoaded();
    const developerToken = await fetchDeveloperToken();

    console.log('[AM Configure] Configuring MusicKit...');
    window.MusicKit.configure({
      developerToken: developerToken,
      app: { name: 'TapeDeck Time Machine', build: 'web' }
    });

    console.log('[AM Configure] Getting instance...');
    // --- CORRECTED FIX: Use 'let' ---
    let instance = null; // Initialize as null, declare with let
    for (let i = 0; i < 5; i++) {
        instance = window.MusicKit.getInstance(); // Assign using let
        if (instance) break;
        console.warn(`[AM Configure] getInstance attempt ${i+1} failed, retrying...`);
        await sleep(200);
    }
    // --- END FIX ---
    if (!instance) throw new Error('MusicKit instance failed after configure and retries.');

    console.log('[AM Configure] Instance obtained.');
    instance.storefrontId = instance.storefrontId || window.mkDefaultStorefront || 'us';
    console.log('[AM Configure] Storefront set to:', instance.storefrontId);

    const storedToken = localStorage.getItem('appleMusicUserToken');
    if (storedToken && !instance.musicUserToken) {
      instance.musicUserToken = storedToken;
      console.log('[AM Configure] Applied stored user token.');
    }

    // --- Register Event Listeners ---
    instance.removeEventListener('authorizationStatusDidChange', handleAuthorizationStatusChange);
    instance.addEventListener('authorizationStatusDidChange', handleAuthorizationStatusChange);
    console.log('[AM Configure] Attached auth listener.');
    
    // Attach Simple Player listeners
    instance.removeEventListener('playbackStateDidChange', simplePlayerStateChanged);
    instance.removeEventListener('nowPlayingItemDidChange', simplePlayerItemChanged);
    instance.addEventListener('playbackStateDidChange', simplePlayerStateChanged);
    instance.addEventListener('nowPlayingItemDidChange', simplePlayerItemChanged);
    console.log('[AM Configure] Attached player listeners.');
    // --- End Register Event Listeners ---

    console.log('[AM Configure] Initial configuration complete. Current auth status:', instance.authorizationStatus);
    return instance;
  }

  function getMusicInstance() {
    if (musicInstance) return Promise.resolve(musicInstance);
    if (!musicInstancePromise) {
      musicInstancePromise = configureMusicKit()
        .then(instance => {
          musicInstance = instance;
          console.log('[AM GetInstance] Initialization successful.');
          updateAmUIState();
          return instance;
        })
        .catch(e => {
          console.error('[AM GetInstance] Initialization failed:', e);
          qs('#amMsg').textContent = 'Failed to initialize Apple Music: ' + (e.message || e);
          musicInstancePromise = null;
          musicInstance = null;
          throw e;
        });
    }
    return musicInstancePromise;
  }

  // Centralized UI Update Function
  function updateAmUIState() {
      const hasToken = !!localStorage.getItem('appleMusicUserToken');
      console.log('[AM UI Update] Updating UI based on token presence:', hasToken);

      qs('#amSign').style.display = hasToken ? 'none' : 'inline-block';
      qs('#amCreate').style.display = hasToken ? 'inline-block' : 'none';
      qs('#amPlay').style.display = hasToken ? 'inline-block' : 'none';

      if (hasToken) {
          if (qs('#amMsg').textContent.startsWith('Sign-in') || qs('#amMsg').textContent.startsWith('Error') || qs('#amMsg').textContent.startsWith('Failed')) {
              qs('#amMsg').textContent = 'Signed in. Generate a list to play or create.';
          }
      } else {
          showSimplePlayer(false); // Hide player
          if (!qs('#amMsg').textContent.startsWith('Error') && !qs('#amMsg').textContent.startsWith('Failed')) {
              qs('#amMsg').textContent = '';
          }
      }
  }

  // Event Handler for Auth Changes
  function handleAuthorizationStatusChange(event) {
      console.log('[AM Event] Auth status changed:', event.authorizationStatus);
      const instance = musicInstance || event.target || window.MusicKit.getInstance();
      if (event.authorizationStatus === 'authorized' && instance && instance.musicUserToken) {
          localStorage.setItem('appleMusicUserToken', instance.musicUserToken);
      } else {
           localStorage.removeItem('appleMusicUserToken');
      }
      updateAmUIState(); // Update UI
  }
  // --- End MusicKit Initialization ---


  // ---------- Native-first sign-in ----------
  async function amSignIn(){
    const Cap = window.Capacitor || {};
    const Plugins = (Cap && Cap.Plugins) || {};
    const Browser = Plugins.Browser;
    qs('#amMsg').textContent = '';

    if (Browser && typeof Browser.open === 'function') {
      const url = `${NATIVE_HOST}/auth/native/?native=1&v=5`;
      console.log('[AM] Native SFSafariViewController →', url);
      qs('#amMsg').textContent = 'Opening Apple sign-in…';
      try {
        await getMusicInstance(); // Ensure configured before native auth
        await Browser.open({ url, presentationStyle: 'fullscreen' });
      } catch (e) {
        console.error('[AM] Browser.open or pre-config failed:', e);
        qs('#amMsg').textContent = 'Failed to open sign-in window: ' + (e.message || e);
      }
      return;
    }

    // Website fallback
    try {
      console.log('[AM] Web Fallback → MusicKit.authorize()');
      qs('#amMsg').textContent = 'Contacting Apple…';
      const m = await getMusicInstance();
      await m.authorize(); // Trigger auth popup
      // Event listener 'authorizationStatusDidChange' will handle UI updates
      qs('#amMsg').textContent = 'Sign-in requested. Check pop-up.';

    } catch(e){
      console.error('[AM] Web fallback failed:', e);
      qs('#amMsg').textContent = 'Sign-in failed: ' + (e.message || e);
      updateAmUIState(); // Ensure UI resets
    }
  }

  // ---------- REST API Search Helper ----------
  async function appleCatalogSearch(term, storefront = 'us', limit = 1) {
    const devToken = await fetchDeveloperToken();
    if (!devToken) { console.error("appleCatalogSearch: Dev token not available."); return null; }
    const url = `https://api.music.apple.com/v1/catalog/${encodeURIComponent(storefront)}/search?term=${encodeURIComponent(term)}&limit=${limit}&types=songs`;
    try {
        const r = await fetch(url, { headers: { 'Authorization': `Bearer ${devToken}` } });
        if (!r.ok) { console.warn(`REST Search failed (${r.status}) for: ${term}`); return null; }
        return await r.json();
    } catch (e) { console.warn(`REST Search network error for "${term}":`, e); return null; }
  }


  // ---------- Play Playlist (Programmatic + Custom UI) ----------
  async function amPlay() { // Renamed from amPlayPlaylist
    qs('#amMsg').textContent = '';
    showSimplePlayer(false); // Hide old player
    
    let m;
    try {
      console.log('[AM Play] Getting MusicKit instance...');
      m = await getMusicInstance();

      if (!m || !m.isAuthorized) {
        console.log('[AM Play] Not authorized.');
        qs('#amMsg').textContent = 'Sign-in required. Please click "Sign in to Apple Music".';
        updateAmUIState(); return;
      }

       // --- Wait for API readiness loop ---
      console.log('[AM Play] Waiting for API readiness...');
      qs('#amMsg').textContent = 'Connecting to Apple Music API...';
      let apiReady = false;
      for (let i = 0; i < 15; i++) { // Retry up to 15 times (3 seconds total)
          if (m && m.api && typeof m.api.search === 'function') {
              apiReady = true; console.log(`[AM Play] API ready after ${i} retries.`); break;
          }
          console.warn(`[AM Play] API not ready on instance 'm', retry ${i+1}...`); await sleep(200);
      }
      if (!apiReady) throw new Error('MusicKit API failed to become ready in time.');
      // --- End Wait ---

      m.storefrontId = m.storefrontId || 'us';
      console.log('[AM Play] Instance ready for search with storefront:', m.storefrontId);

    } catch (e) {
      console.error('[AM Play] init/check failed:', e);
      qs('#amMsg').textContent = 'Apple Music connection issue: ' + (e.message || e);
      updateAmUIState(); return;
    }

    // --- Check for tracks or created playlist ---
    let queueOptions = {};
    if (lastTracks?.length > 0) {
        console.log('[AM Play] Searching for tracks from generated list...');
        qs('#amMsg').textContent = `Searching for ${lastTracks.length} tracks...`;
        const songIds = [];
        let i = 0;
        const storefront = m.storefrontId;
        for (const t of lastTracks) {
          i++;
          if (i % 5 === 0 || i === lastTracks.length) { qs('#amMsg').textContent = `Searching... (${i}/${lastTracks.length})`; }
          try {
            const term = `${t.artist} ${t.title}`; let id = null;
            if (m.api && typeof m.api.search === 'function') {
                try { const res = await withTimeout(m.api.search(term, { types: ['songs'], limit: 1, storefront: storefront }), 5000); id = res?.songs?.data?.[0]?.id; }
                catch (apiSearchErr) { console.warn(`MusicKit API search failed for "${term}", trying REST:`, apiSearchErr); id = null; }
            } else { console.warn(`MusicKit API search not available, falling back to REST for: ${term}`); }
            if (!id) { console.log(`[AM Play] Falling back to REST search for: ${term}`); const res = await appleCatalogSearch(term, storefront, 1); id = res?.results?.songs?.data?.[0]?.id; }
            if (id) { songIds.push(id); } else { console.warn(`[AM Play] Track not found in ${storefront}: ${term}`); }
            await sleep(100);
          } catch (e) { console.warn(`[AM Play] search loop error for "${t.artist} - ${t.title}":`, e); }
        }
        if (!songIds.length) { qs('#amMsg').textContent = 'None of the tracks could be found in Apple Music.'; return; }
        qs('#amMsg').textContent = `Found ${songIds.length} tracks. Adding to queue...`;
        queueOptions = { songs: songIds };
    } else if (currentPlaylistInfo.id) {
        console.log('[AM Play] No generated tracks, playing created playlist ID:', currentPlaylistInfo.id);
        qs('#amMsg').textContent = `Loading created playlist...`;
        queueOptions = { playlist: currentPlaylistInfo.id }; // Play by library playlist ID
    } else {
        qs('#amMsg').textContent = 'Please generate a tracklist or create a playlist first.';
        return;
    }

    // --- Play ---
    try {
      if (!m.player || typeof m.play !== 'function' || typeof m.setQueue !== 'function') {
           console.error('[AM Play] Player API not ready at playback time.');
           throw new Error('MusicKit Player failed to become ready.');
      }
      console.log('[AM Play] Setting queue...', queueOptions);
      await m.setQueue(queueOptions);
      await m.play();
      showSimplePlayer(true); // Show the simple player
      updateSimplePlayerUI(); // Update with initial track
      qs('#amMsg').textContent = `Now playing!`;
      qs('#spMsg').textContent = '';
    } catch (e) {
      console.error('[AM Play] playback failed:', e);
      qs('#amMsg').textContent = 'Error starting playback: ' + (e.message || e);
      qs('#spMsg').textContent = 'Playback Error: ' + (e.message || e);
      showSimplePlayer(true);
    }
  }

  // ---------- Create playlist (shared) ----------
  async function amCreatePlaylist(){
    const userToken = localStorage.getItem('appleMusicUserToken');
    if(!userToken){ qs('#amMsg').textContent='Please sign in first.'; updateAmUIState(); return; }
    if(!lastTracks?.length){ qs('#amMsg').textContent='Generate a tracklist first.'; return; }

    qs('#amMsg').textContent='Creating playlist…';
    showSimplePlayer(false); // Hide simple player

    try{
      const name = `TimeDeck — ${qs('#date').value} — ${qs('#genre').value.toLowerCase()}`;
      const r = await withTimeout(fetch(`${API}/v1/apple/create-playlist`, {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ userToken, name, tracks: lastTracks.map(t=>({artist:t.artist,title:t.title})) })
      }));
      if(!r.ok){
        const j = await r.json().catch(() => ({ detail: 'Unknown error during create' }));
        throw new Error(j.detail || `Create failed with status ${r.status}`);
      }
      const j = await r.json();
      const { playlist_id, added_count, total_tracks_searched } = j || {};

      if (!playlist_id) throw new Error("Playlist created, but backend didn't return an ID.");

      // Store playlist info
      currentPlaylistInfo.id = playlist_id;
      currentPlaylistInfo.url = j.playlist_url;
      currentPlaylistInfo.storefront = j.storefront || 'us';
      
      qs('#amMsg').textContent = `Playlist created! Added ${added_count} of ${total_tracks_searched} tracks.`;

    } catch(e){
      console.error('[AM Create] Failed:', e);
      qs('#amMsg').textContent = 'Create failed: ' + (e.message || String(e));
    }
    updateAmUIState(); // Update UI (will show Play button now)
  }

  // ---------- Simple Programmatic Player (UI only) ----------
  let simplePlayerInterval = null;

  function showSimplePlayer(show = true) {
      const sp = qs('#simplePlayer');
      sp.style.display = show ? 'block' : 'none';
      if (!show && simplePlayerInterval) {
          clearInterval(simplePlayerInterval);
          simplePlayerInterval = null;
      }
  }

  function updateSimplePlayerUI() {
      // Check if instance and player are ready
      if (!musicInstance || !musicInstance.player) {
          qs('#spTitle').textContent = 'Player not ready...';
          qs('#spBtnPlayPause').textContent = '▶';
          return;
      }
      // Check if an item is loaded
      const item = musicInstance.player.nowPlayingItem;
      if (!item) {
          qs('#spTitle').textContent = 'Queue empty or loading...';
          qs('#spBtnPlayPause').textContent = '▶';
          return;
      }
      const attr = item.attributes || {};
      qs('#spTitle').textContent = `${attr.artistName || 'Unknown Artist'} - ${attr.name || 'Unknown Track'}`;
      qs('#spBtnPlayPause').textContent = musicInstance.player.isPlaying ? '⏸' : '▶';
  }
  function simplePlayerStateChanged(event) {
      console.log('[AM Simple Player] State changed:', event.state);
      updateSimplePlayerUI();
  }
  function simplePlayerItemChanged(event) {
      console.log('[AM Simple Player] Item changed');
      updateSimplePlayerUI();
  }

  // --- Simple Player Controls Wiring ---
  qs('#spBtnPlayPause').onclick = async () => {
    try { 
        const m = await getMusicInstance(); 
        if (!m || !m.player) return;
        if (m.player.isPlaying) {
            await m.pause();
        } else {
            // Check if it's at the end of queue, if so, restart
            if (m.player.playbackState === MusicKit.PlaybackStates.ended) {
                 await m.play(); // Should restart queue
            } else {
                 await m.play();
            }
        }
        // Event listener (simplePlayerStateChanged) will update the icon
    } catch(e){ console.error("SP Play/pause error:", e);}
  };
  qs('#spBtnPrev').onclick = async () => {
     try { const m = await getMusicInstance(); if(m && m.player) await m.skipToPreviousItem(); } 
     catch(e){ console.warn("SP Skip Previous failed:", e); }
  };
  qs('#spBtnNext').onclick = async () => {
     try { const m = await getMusicInstance(); if(m && m.player) await m.skipToNextItem(); }
     catch(e){ console.warn("SP Skip Next failed:", e); }
  };


  // ---------- Initialize MusicKit on Load ----------
  document.addEventListener('DOMContentLoaded', () => {
      console.log('[AM Init] DOMContentLoaded, attempting initial MusicKit setup...');
      currentPlaylistInfo.id = localStorage.getItem('applePlaylistId');
      currentPlaylistInfo.url = localStorage.getItem('applePlaylistUrl');
      currentPlaylistInfo.storefront = localStorage.getItem('applePlaylistStorefront') || 'us';

      getMusicInstance().catch(e => {
          console.error("Initial MusicKit setup failed on load:", e);
      });
      updateAmUIState();
  });

  // ---------- wire up ----------
  qs('#go').onclick = simulate;
  qs('#amSign').onclick = amSignIn;
  qs('#amCreate').onclick = amCreatePlaylist;
  qs('#amPlay').onclick = amPlay; // Main "Play" button

  setTab('yt');
</script>

</body>
</html>

